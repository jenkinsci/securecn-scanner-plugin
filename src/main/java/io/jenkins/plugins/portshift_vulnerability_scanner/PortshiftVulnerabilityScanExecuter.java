package io.jenkins.plugins.portshift_vulnerability_scanner;


import hudson.FilePath;
import hudson.Launcher;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.util.ArgumentListBuilder;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.UUID;
import org.apache.commons.lang.BooleanUtils;
import org.apache.commons.lang.StringUtils;


public class PortshiftVulnerabilityScanExecuter {

  public static final String EXEC_FILE_NAME = "securecn_deployment_cli";
  public static final String PRODUCTION_URL = "securecn.cisco.com";
  public static final String PASSWORD_MASK = "********";

  public static int execute(Run<?, ?> build, FilePath workspace, Launcher launcher, TaskListener listener,
      String secureCnAccessKey,
      String secretKey, String imageName, String url, String highestSeverityAllowed,
      String dockerRegistryUsername, String dockerRegistryPassword, String highestSeverityAllowedDf,
      Boolean pushLocalImage) {

    listener.getLogger().println(String
        .format(
            "Hello, parameters for SecureCN scanner:%nsecureCnAccessKey: %s%nsecretKey: %s%nimageName: %s%nurl: "
                + "%s%nhighestSeverityAllowed: %s%nhighestSeverityAllowedDf: %s%ndockerRegistryUsername:"
                + " %s%ndockerRegistryPassword: %s%npush local image: %s%n",
            secureCnAccessKey, PASSWORD_MASK, imageName, url, highestSeverityAllowed, highestSeverityAllowedDf,
            dockerRegistryUsername, StringUtils.isEmpty(dockerRegistryPassword) ? null : PASSWORD_MASK,
            pushLocalImage));
    try {
      ByteArrayOutputStream output = new ByteArrayOutputStream();
      int exitCode = runScan(launcher, listener, secureCnAccessKey, secretKey, imageName, url,
          output, highestSeverityAllowed, dockerRegistryUsername, dockerRegistryPassword, highestSeverityAllowedDf,
          pushLocalImage);
      if (exitCode == 0) {
        listener.getLogger().println("Execution succeeded.");
      } else {
        listener.getLogger().println("Execution failed.");
      }

      return exitCode;
    } catch (Exception e) {
      listener.getLogger().println("Execution failed: " + e.getMessage());
      listener.getLogger().println("Execution failed: " + Arrays.toString(e.getStackTrace()));
      return 4;
    }
  }

  private static int runScan(Launcher launcher, TaskListener listener,
      String secureCnAccessKey, String secretKey,
      String imageName, String url, ByteArrayOutputStream output,
      String highestSeverityAllowed, String dockerRegistryUsername, String dockerRegistryPassword,
      String highestSeverityAllowedDf, Boolean pushLocalImage)
      throws Exception {

    String cliPath = downloadCliFile(listener, url, launcher);

    try {
      return runPortshiftCli(launcher, listener, secureCnAccessKey, secretKey, imageName, url, output,
          highestSeverityAllowed, dockerRegistryUsername, dockerRegistryPassword, highestSeverityAllowedDf,
          pushLocalImage, cliPath);
    } finally {
      deleteCli(launcher, listener, cliPath);
    }
  }

  private static int runPortshiftCli(Launcher launcher, TaskListener listener, String secureCnAccessKey,
      String secretKey, String imageName, String url, ByteArrayOutputStream output, String highestSeverityAllowed,
      String dockerRegistryUsername, String dockerRegistryPassword, String highestSeverityAllowedDf,
      Boolean pushLocalImage, String portshiftCliPath) throws IOException, InterruptedException {

    Launcher.ProcStarter ps = launcher.launch();
    ArgumentListBuilder args = new ArgumentListBuilder();

    args.add(portshiftCliPath).add("run-vulnerability-scan").add("--access-key")
        .add(secureCnAccessKey).add("--secret-key").add(secretKey, true).add("--image-name").add(imageName);

    if (!StringUtils.isEmpty(url)) {
      args.add("--url").add(url);
    }

    if (!StringUtils.isEmpty(highestSeverityAllowed)) {
      args.add("--highest-severity-allowed").add(highestSeverityAllowed);
    }

    if (!StringUtils.isEmpty(highestSeverityAllowedDf)) {
      args.add("--df-highest-severity-allowed").add(highestSeverityAllowedDf);
    }

    if (!StringUtils.isEmpty(dockerRegistryPassword) && !StringUtils.isEmpty(dockerRegistryUsername)) {
      args.add("--username").add(dockerRegistryUsername).add("--password").add(dockerRegistryPassword, true);
    }

    if (BooleanUtils.isTrue(pushLocalImage)) {
      args.add("--local").add("--push-local");
    }

    ps.cmds(args);
    ps.stdin(null);
    ps.stdout(output);
    ps.stderr(listener.getLogger());

    listener.getLogger().println("Vulnerability scan in progress...");
    int join = ps.masks(args.toMaskArray()).join();

    listener.getLogger().println(output.toString("UTF-8"));

    return join; // RUN !
  }

  private static void runBasicCommand(Launcher launcher, TaskListener listener, String... commands)
      throws Exception {
    Launcher.ProcStarter ps = launcher.launch();
    ArgumentListBuilder args = new ArgumentListBuilder();
    for (String command : commands) {
      args.add(command);
    }
    ps.cmds(args);
    ps.stdin(null);
    ps.stdout(listener.getLogger());
    ps.stderr(listener.getLogger());
    ps.cmds(args);
    if (ps.join() != 0) {
      throw new Exception("error in command execution: " + Arrays.toString(commands));
    }
  }

  private static void downloadExecutable(Launcher launcher, String portshiftCliPath, String localCliPath,
      TaskListener listener) throws Exception {

    runBasicCommand(launcher, listener, "wget", "-P", getTmpCliDirectory(localCliPath), portshiftCliPath);
  }

  private static void chmodCliExecutable(Launcher launcher, String portshiftCliPath, TaskListener listener)
      throws Exception{

    runBasicCommand(launcher, listener, "chmod", "+x", portshiftCliPath);
  }

  private static void deleteCli(Launcher launcher, TaskListener listener, String portshiftCliPath)
      throws Exception {

    runBasicCommand(launcher, listener, "rm", "-rf", getTmpCliDirectory(portshiftCliPath));
  }

  private static String getTmpCliDirectory(String portshiftCliPath) {
    return portshiftCliPath.replace(EXEC_FILE_NAME, "");
  }

  private static String downloadCliFile(TaskListener listener, String mgmtUrl, Launcher launcher)
      throws Exception {

    String cliFilePath = getCliPath(listener, launcher);

    try {
      mgmtUrl = StringUtils.isEmpty(mgmtUrl) ? PRODUCTION_URL : mgmtUrl;
      String urlToDownloadCli = "https://" + mgmtUrl + "/tools/cli/" + EXEC_FILE_NAME;

      listener.getLogger().println("download cli from: " + urlToDownloadCli);

      downloadExecutable(launcher, urlToDownloadCli, cliFilePath, listener);
      chmodCliExecutable(launcher, cliFilePath, listener);

    } catch (Exception e) {
      listener.getLogger().println("Exception: " + e.getMessage());
      throw e;
    }
    return cliFilePath;
  }

  private static String getCliPath(TaskListener listener, Launcher launcher) throws Exception {
    String cliDirectory = "/tmp/" + UUID.randomUUID().toString() + "/";

    runBasicCommand(launcher, listener, "mkdir", cliDirectory);

    return cliDirectory + EXEC_FILE_NAME;
  }
}
